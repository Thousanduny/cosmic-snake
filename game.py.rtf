import pygame
import random
import math
import sys

# Инициализация Pygame
pygame.init()

# Константы
WIDTH, HEIGHT = 800, 600
GRID_SIZE = 20
GRID_WIDTH = WIDTH // GRID_SIZE
GRID_HEIGHT = HEIGHT // GRID_SIZE
FPS = 60

# Цвета
BACKGROUND = (15, 15, 25)
SNAKE_HEAD = (50, 200, 100)
SNAKE_BODY = (30, 150, 80)
FOOD_COLOR = (220, 80, 60)
PORTAL_COLOR = (150, 80, 200)
WALL_COLOR = (100, 100, 120)
TEXT_COLOR = (220, 220, 220)

# Направления
UP = (0, -1)
DOWN = (0, 1)
LEFT = (-1, 0)
RIGHT = (1, 0)

class Portal:
    def __init__(self):
        self.position = self.random_position()
        self.active = False
        self.target = None
        self.timer = 0
        
    def random_position(self):
        return (random.randint(2, GRID_WIDTH - 3), random.randint(2, GRID_HEIGHT - 3))
    
    def activate(self, target_portal):
        self.active = True
        self.target = target_portal
        self.timer = 300  # 5 секунд при 60 FPS
        
    def update(self):
        if self.active:
            self.timer -= 1
            if self.timer <= 0:
                self.active = False
                self.target = None

class SnakeGame:
    def __init__(self):
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("Космическая Змейка")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 36)
        self.small_font = pygame.font.Font(None, 24)
        
        self.reset_game()
        
    def reset_game(self):
        # Змейка начинается в центре
        self.snake = [(GRID_WIDTH // 2, GRID_HEIGHT // 2)]
        self.direction = RIGHT
        self.next_direction = RIGHT
        self.score = 0
        self.game_over = False
        self.speed = 8
        self.grow_pending = 3  # Начальная длина
        
        # Еда
        self.food = self.generate_food()
        self.food_timer = 0
        
        # Порталы
        self.portal1 = Portal()
        self.portal2 = Portal()
        self.portal_cooldown = 0
        
        # Стены
        self.walls = self.generate_walls()
        
        # Эффекты
        self.particles = []
        
    def generate_walls(self):
        walls = []
        # Границы
        for x in range(GRID_WIDTH):
            walls.append((x, 0))
            walls.append((x, GRID_HEIGHT - 1))
        for y in range(GRID_HEIGHT):
            walls.append((0, y))
            walls.append((GRID_WIDTH - 1, y))
        
        # Случайные препятствия
        for _ in range(15):
            x = random.randint(3, GRID_WIDTH - 4)
            y = random.randint(3, GRID_HEIGHT - 4)
            length = random.randint(2, 5)
            horizontal = random.choice([True, False])
            
            for i in range(length):
                if horizontal:
                    wall_pos = (x + i, y)
                else:
                    wall_pos = (x, y + i)
                if wall_pos not in walls:
                    walls.append(wall_pos)
        
        return walls
    
    def generate_food(self):
        while True:
            pos = (random.randint(1, GRID_WIDTH - 2), random.randint(1, GRID_HEIGHT - 2))
            if pos not in self.snake and pos not in self.walls:
                return pos
    
    def handle_input(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if self.game_over:
                    if event.key == pygame.K_r:
                        self.reset_game()
                else:
                    if event.key == pygame.K_UP and self.direction != DOWN:
                        self.next_direction = UP
                    elif event.key == pygame.K_DOWN and self.direction != UP:
                        self.next_direction = DOWN
                    elif event.key == pygame.K_LEFT and self.direction != RIGHT:
                        self.next_direction = LEFT
                    elif event.key == pygame.K_RIGHT and self.direction != LEFT:
                        self.next_direction = RIGHT
                    elif event.key == pygame.K_SPACE and self.portal_cooldown <= 0:
                        self.activate_portals()
    
    def activate_portals(self):
        if not self.portal1.active and not self.portal2.active:
            self.portal1.position = (self.snake[0][0] - self.direction[0], 
                                   self.snake[0][1] - self.direction[1])
            self.portal2.position = self.portal2.random_position()
            
            # Убедимся, что портал не появляется в змейке или стене
            while (self.portal2.position in self.snake or 
                   self.portal2.position in self.walls or
                   self.portal2.position == self.food):
                self.portal2.position = self.portal2.random_position()
            
            self.portal1.activate(self.portal2)
            self.portal2.activate(self.portal1)
            self.portal_cooldown = 180  # 3 секунды
    
    def update(self):
        if self.game_over:
            return
            
        self.direction = self.next_direction
        
        # Обновление таймеров
        if self.portal_cooldown > 0:
            self.portal_cooldown -= 1
        self.portal1.update()
        self.portal2.update()
        self.food_timer += 1
        
        # Обновление частиц
        self.particles = [p for p in self.particles if p[4] > 0]
        for i, (x, y, dx, dy, life) in enumerate(self.particles):
            self.particles[i] = (x + dx, y + dy, dx, dy, life - 1)
        
        # Движение змейки
        head_x, head_y = self.snake[0]
        new_head = (head_x + self.direction[0], head_y + self.direction[1])
        
        # Проверка телепортации через порталы
        if self.portal1.active and new_head == self.portal1.position:
            new_head = self.portal2.position
            self.create_particles(new_head[0] * GRID_SIZE, new_head[1] * GRID_SIZE, 20)
        elif self.portal2.active and new_head == self.portal2.position:
            new_head = self.portal1.position
            self.create_particles(new_head[0] * GRID_SIZE, new_head[1] * GRID_SIZE, 20)
        
        # Проверка столкновений
        if (new_head in self.snake or 
            new_head in self.walls or
            not (0 <= new_head[0] < GRID_WIDTH) or 
            not (0 <= new_head[1] < GRID_HEIGHT)):
            self.game_over = True
            self.create_particles(head_x * GRID_SIZE, head_y * GRID_SIZE, 30)
            return
        
        self.snake.insert(0, new_head)
        
        # Проверка съедания еды
        if new_head == self.food:
            self.score += 10
            self.grow_pending += 1
            self.food = self.generate_food()
            self.food_timer = 0
            self.create_particles(self.food[0] * GRID_SIZE, self.food[1] * GRID_SIZE, 15)
            
            # Увеличение скорости каждые 50 очков
            if self.score % 50 == 0 and self.speed < 20:
                self.speed += 1
        else:
            # Удаление хвоста, если не нужно расти
            if self.grow_pending > 0:
                self.grow_pending -= 1
            else:
                self.snake.pop()
    
    def create_particles(self, x, y, count):
        for _ in range(count):
            angle = random.uniform(0, 2 * math.pi)
            speed = random.uniform(1, 3)
            dx = math.cos(angle) * speed
            dy = math.sin(angle) * speed
            life = random.randint(20, 40)
            self.particles.append((x + GRID_SIZE // 2, y + GRID_SIZE // 2, dx, dy, life))
    
    def draw(self):
        self.screen.fill(BACKGROUND)
        
        # Рисование сетки (если нужно)
        for x in range(0, WIDTH, GRID_SIZE):
            pygame.draw.line(self.screen, (30, 30, 40), (x, 0), (x, HEIGHT))
        for y in range(0, HEIGHT, GRID_SIZE):
            pygame.draw.line(self.screen, (30, 30, 40), (0, y), (WIDTH, y))
        
        # Рисование стен
        for wall in self.walls:
            rect = pygame.Rect(wall[0] * GRID_SIZE, wall[1] * GRID_SIZE, GRID_SIZE, GRID_SIZE)
            pygame.draw.rect(self.screen, WALL_COLOR, rect)
            pygame.draw.rect(self.screen, (80, 80, 100), rect, 1)
        
        # Рисование порталов
        if self.portal1.active:
            self.draw_portal(self.portal1)
        if self.portal2.active:
            self.draw_portal(self.portal2)
        
        # Рисование еды с пульсацией
        food_size = GRID_SIZE - 4 + math.sin(self.food_timer * 0.1) * 2
        food_rect = pygame.Rect(
            self.food[0] * GRID_SIZE + (GRID_SIZE - food_size) // 2,
            self.food[1] * GRID_SIZE + (GRID_SIZE - food_size) // 2,
            food_size, food_size
        )
        pygame.draw.rect(self.screen, FOOD_COLOR, food_rect)
        
        # Рисование змейки
        for i, (x, y) in enumerate(self.snake):
            color = SNAKE_HEAD if i == 0 else SNAKE_BODY
            rect = pygame.Rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
            pygame.draw.rect(self.screen, color, rect)
            pygame.draw.rect(self.screen, (color[0] - 20, color[1] - 20, color[2] - 20), rect, 1)
            
            # Глаза у головы
            if i == 0:
                eye_size = GRID_SIZE // 5
                # Определяем направление для размещения глаз
                if self.direction == RIGHT:
                    left_eye = (x * GRID_SIZE + GRID_SIZE - eye_size - 2, y * GRID_SIZE + 5)
                    right_eye = (x * GRID_SIZE + GRID_SIZE - eye_size - 2, y * GRID_SIZE + GRID_SIZE - 5 - eye_size)
                elif self.direction == LEFT:
                    left_eye = (x * GRID_SIZE + 2, y * GRID_SIZE + 5)
                    right_eye = (x * GRID_SIZE + 2, y * GRID_SIZE + GRID_SIZE - 5 - eye_size)
                elif self.direction == UP:
                    left_eye = (x * GRID_SIZE + 5, y * GRID_SIZE + 2)
                    right_eye = (x * GRID_SIZE + GRID_SIZE - 5 - eye_size, y * GRID_SIZE + 2)
                else:  # DOWN
                    left_eye = (x * GRID_SIZE + 5, y * GRID_SIZE + GRID_SIZE - eye_size - 2)
                    right_eye = (x * GRID_SIZE + GRID_SIZE - 5 - eye_size, y * GRID_SIZE + GRID_SIZE - eye_size - 2)
                
                pygame.draw.rect(self.screen, (255, 255, 255), 
                               pygame.Rect(left_eye[0], left_eye[1], eye_size, eye_size))
                pygame.draw.rect(self.screen, (255, 255, 255), 
                               pygame.Rect(right_eye[0], right_eye[1], eye_size, eye_size))
        
        # Рисование частиц
        for x, y, dx, dy, life in self.particles:
            alpha = min(255, life * 6)
            color = (255, 200, 100, alpha)
            pygame.draw.circle(self.screen, color[:3], (int(x), int(y)), 2)
        
        # Рисование интерфейса
        score_text = self.font.render(f"Очки: {self.score}", True, TEXT_COLOR)
        self.screen.blit(score_text, (10, 10))
        
        speed_text = self.small_font.render(f"Скорость: {self.speed}", True, TEXT_COLOR)
        self.screen.blit(speed_text, (10, 50))
        
        portal_text = self.small_font.render(f"Портал: {'Готов' if self.portal_cooldown <= 0 else 'Перезарядка'}", 
                                           True, TEXT_COLOR)
        self.screen.blit(portal_text, (10, 75))
        
        if self.game_over:
            game_over_font = pygame.font.Font(None, 72)
            game_over_text = game_over_font.render("ИГРА ОКОНЧЕНА", True, (220, 60, 60))
            restart_text = self.font.render("Нажми R для перезапуска", True, TEXT_COLOR)
            
            text_rect = game_over_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 30))
            restart_rect = restart_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 30))
            
            self.screen.blit(game_over_text, text_rect)
            self.screen.blit(restart_text, restart_rect)
        
        pygame.display.flip()
    
    def draw_portal(self, portal):
        x, y = portal.position
        center_x = x * GRID_SIZE + GRID_SIZE // 2
        center_y = y * GRID_SIZE + GRID_SIZE // 2
        
        # Анимированный портал
        time = pygame.time.get_ticks() * 0.01
        radius = GRID_SIZE // 2 + math.sin(time) * 2
        
        for i in range(5):
            current_radius = radius - i * 2
            alpha = 200 - i * 40
            color = (PORTAL_COLOR[0], PORTAL_COLOR[1], PORTAL_COLOR[2])
            pygame.draw.circle(self.screen, color, (center_x, center_y), int(current_radius))
            pygame.draw.circle(self.screen, (200, 200, 255), (center_x, center_y), int(current_radius), 1)
    
    def run(self):
        while True:
            self.handle_input()
            self.update()
            self.draw()
            self.clock.tick(self.speed)

if __name__ == "__main__":
    game = SnakeGame()
    game.run()
